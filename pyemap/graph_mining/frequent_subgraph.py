from telnetlib import GA
import numpy as np
from numpy import linalg as LA
from Bio.PDB import Superimposer
from .utils import get_graph_matcher, write_graph_smiles, make_pretty_subgraph
from reportlab.graphics import renderPM
from networkx.drawing.nx_agraph import to_agraph
import networkx as nx
from PIL import Image
from functools import total_ordering
import tempfile

def _get_sequence(G):
    ''' Gets sequence for protein subgraph w.r.t multiple sequence alignment

    Parameters
    -----------
    G: :class:`networkx.Graph`
        Protein subgraph
    
    Returns
    -------
    seq: list of int
        Returns list of aligned residue numbers

    '''
    src = None
    for node in G.nodes:
        try:
            if G.nodes[node]['aligned_resnum'] < G.nodes[src]['aligned_resnum']:
                src = node
        except:
                src = node
    seq = list(nx.dfs_preorder_nodes(G, source=src))
    seq = [G.nodes[node]['aligned_resnum'] for node in seq]
    seq = [0 if x=='X' else int(x) for x in seq]
    return seq

def _do_fiedler_clustering(D,A,all_graphs):
    ''' Clusters list of graphs given a degree and adjacency matrix using the Fiedler eigenvector.

        Each protein subgraph is assigned a unique ID based on it's grouping. 

    Parameters
    ----------
    D: :class:`numpy.array` of float
        Degree matrix
    A :class:`numpy.array` of float
        Adjacency matrix
    all_graphs: list of :class:`networkx.Graph`
        Graphs under consideration

    Returns
    --------
    groups: dict of str: (list of class:`networkx.Graph`)
        Sorted protein subgraphs
    protein_subgraphs: dict of str: :class:`networkx.Graph`
        Protein subgraphs and their corresponding IDs

    Notes
    ------
    See https://en.wikipedia.org/wiki/Algebraic_connectivity.
    For implementation in the context of protein graphs, see J. Mol. Biol. (1999) 292, 441-464.

    '''
    L = D - A
    eigv, eigvc = LA.eig(L)
    eigv = np.real(eigv)
    eigvc = np.real(eigvc)
    idx = eigv.argsort()
    eigv = eigv[idx]
    eigvc = eigvc[:, idx]
    # second lowest eigenvector
    eigvc2 = eigvc[:, 1][:-1]
    groups = {}
    protein_subgraphs = {}
    for i, val in enumerate(eigvc2):
        rounded_val = np.round(val, decimals=6)
        if rounded_val not in groups:
            groups[rounded_val] = [all_graphs[i]]
        else:
            graphs = groups[rounded_val]
            graphs.append(all_graphs[i])
            groups[rounded_val] = graphs
    tuples = []
    for key, val in groups.items():
        tuples.append((key, val))
    # largest groups first
    groups = {}
    tuples.sort(key=lambda x: len(x[1]), reverse=True)
    for idx, tuple1 in enumerate(tuples):
        key, group = tuple1
        pdb_list = []
        for graph in group:
            pdb_list.append(graph.graph['pdb_id'])
            id = graph.graph['pdb_id'] + "(" + str(idx + 1) + ")-" + str(
                pdb_list.count(graph.graph['pdb_id']))
            protein_subgraphs[id] = graph
        groups[idx + 1] = group
    return groups,protein_subgraphs

@total_ordering
class SubgraphPattern():
    '''
    Stores all information regarding an identified subgraph pattern.

    Attributes
    ----------
    id: str
        Unique identifier for subgraph pattern. 
    G: :class:`networkx.Graph`
        Graph representation of this subgraph pattern.
    support: list of str
        List of PDB IDs which contain this subgraph
    protein_subgraphs: dict str: :class:`networkx.Graph`
        Dict which contains protein subgraphs which match this pattern. Each entry has a unique identifier and a
        :class:`networkx.Graph` derived from the graphs generated by the :class:`~pyemap.emap` class which match 
        the pattern of this pattern.
    groups: dict of str: list of :class:`networkx.Graph`
        Protein subgraphs clustered into groups
    support_number: int
        Number of PDBs this subgraph pattern was identified in 
    
    '''
    def __init__(self, G, graph_number, support, res_to_num_label, edge_thresholds):
        '''Initializes SubgraphPattern object.

        Parameters
        ----------
        G: :class:`networkx.Graph`
            Graph representation of this subgraph pattern 
        graph_number: int
            Unique numerical ID for this subgraph pattern
        support: list of str
            List of PDB IDs which contain this subgraph
        res_to_num_label: dict of str: int
            Mapping of residue types to numerical node labels
        edge_thresholds: list of float
            Edge thresholds which define edge labels

        '''
        self.G = G.copy()
        self.support = support
        self.total_support = {}
        self.protein_subgraphs = {}
        self.groups = {}
        self.res_to_num_label = res_to_num_label
        self.edge_thresholds = edge_thresholds
        self.support_number = len(support)
        self.id = str(graph_number+1) + "_" + str(write_graph_smiles(self.G)) + "_" + str(self.support_number)
        if "#" in self.id:
            self._file_id = self.id.replace("#","NP")
        else:
            self._file_id = self.id
        for node in self.G.nodes:
            if self.G.nodes[node]['label'] == "#":
                self.G.nodes[node]['label'] = "NP"

    def __lt__(self, other):
        if self.support_number != other.support_number:
            return self.support_number < other.support_number
        elif str(write_graph_smiles(self.G)) != str(write_graph_smiles(other.G)):
            return str(write_graph_smiles(self.G)) < str(write_graph_smiles(other.G))
        else:
            return self.G.size(weight="num_label") < other.G.size(weight="num_label")       

    def __eq__(self,other):
        return self.G == other.G

    def _update_id(self,graph_number):
        self.id = str(graph_number+1) + self.id[self.id.index('_'):]
        if "#" in self.id:
            self._file_id = self.id.replace("#","NP")
        else:
            self._file_id = self.id

    def general_report(self):
        ''' Generates general report which describes this subgraph pattern.

        Returns
        --------
        full_str: str
            General report which describes this subgraph pattern

        '''
        full_str = ""
        full_str += "ID:" + str(self.id) + "\n"
        full_str += "Support:" + str(self.support_number) + "\n"
        full_str += "Where:" + str(list(self.support.keys())) + "\n"
        full_str += "Adjacency list:\n"
        G = self.G
        for node in G.nodes:
            full_str += G.nodes[node]['label'] + str(node) + ":["
            for neighbor in G.neighbors(node):
                full_str += G.nodes[neighbor]['label'] + str(neighbor) + "(" + str(
                    G.edges[(node, neighbor)]['num_label']) + "), "
            full_str = full_str[:-2]
            full_str += "]\n"
        return full_str

    def full_report(self):
        ''' Returns a full report of all protein subgraphs which match this pattern.

        Returns
        -------
        full_str: str
            Report of protein subgraphs which match this pattern

        '''
        full_str = self.general_report()
        if len(self.protein_subgraphs) == 0:
            full_str += "Please run `find_protein_subgraphs' to get a full report.\n"
            return full_str
        full_str += str(len(self.protein_subgraphs)) + " subgraphs matching this pattern were found.\n"
        full_str += "Graphs are classified based on " + self.clustering_option + " similarity.\n\n"
        for key in self.groups:
            graphs = self.groups[key]
            full_str += "Group " + str(key) + ": " + str(len(graphs)) + " members\n---------------\n"
            for graph in graphs:
                full_str += self._report_for_graph(graph) + "\n"
        return full_str

    def _report_for_graph(self, G):
        ''' Generates report for a given protein subgraph

        '''
        full_str = ""
        full_str += str(G.graph['id']) + "\n"
        full_str += "Nodes\n"
        for node in G.nodes:
            full_str += G.nodes[node]['label']
            full_str += " Position in alignment:" + str(G.nodes[node]['aligned_resnum'])
            full_str += "\n"
        full_str += "Adjacency list:\n"
        for node in G.nodes:
            full_str += G.nodes[node]['label'] + ":["
            for neighbor in G.neighbors(node):
                dist = '{0:.2f}'.format(G.edges[(node, neighbor)]['distance'])
                full_str += G.nodes[neighbor]['label'] + "(" + str(dist) + "), "
            full_str = full_str[:-2]
            full_str += "]\n"
        return full_str

    def _gen_node_rep(self):
        ''' Generates string representation of graph

        '''
        node_rep = ""
        for node, node_data in self.G.nodes(data=True):
            node_rep = ''.join([node_rep, node_data['label']])
        return node_rep

    def _visualize_subgraph_in_ngl(self, emap, G):
        ''' Gets visualization of subgraph in NGL viewer

        Parameters
        ----------
        emap: :class:`~pyemap.emap`
            :class:`~pyemap.emap` object containing the protein subgraph
        G: class:`networkx.Graph`
            Protein subgraph to visualize in NGL viewer

        '''
        colors = {"F": "orange", "Y": "blue", "W": "red", "H": "green"}
        label_texts = []
        labeled_atoms = []
        color_list = []
        selection_strs = []
        for res in G.nodes:
            label_texts.append(res)
            try:
                if res not in emap.eta_moieties:
                    color_list.append(colors[res[0]])
                    labeled_atoms.append(".CA")
                else:
                    color_list.append("pink")
                    labeled_atoms.append(next(emap.residues[res].get_atoms()).name)
            except KeyError:
                color_list.append("pink")
                labeled_atoms.append(next(emap.residues[res].get_atoms()).name)
            selection_strs.append(emap.residues[res].ngl_string)
        return label_texts, labeled_atoms, color_list, selection_strs

    def find_protein_subgraphs(self,clustering_option="structural"):
        ''' Finds protein subgraphs which match this pattern.

        This function must be executed to analyze protein subgraphs.

        Parameters
        -----------
        clustering_option: str, optional
            Either 'structural' or 'sequence'

        Notes
        ------
        Graphs are clustered by both sequence and structrual similarity, and the results are stored in 
        `self._structural_groups`, `self._sequence_groups` etc. The clustering_option argument used here determines 
        which one of these groupings is used for `self.groups` and `self.protein_subgraphs`. This can be changed 
        at any time by calling :func:`pyemap.graph_mining.frequent_subgraph.SubgraphPattern.set_clustering` and specifying the 
        other clustering option.

        '''
        self.groups = {}
        self.protein_subgraphs = {}
        all_graphs = []
        for pdb_id in self.support:
            all_graphs += self._find_subgraph_in_pdb(pdb_id)
        if len(all_graphs) > 1:
            D,A = self._structural_clustering(all_graphs)
            self._structural_groups,self._structural_ids = _do_fiedler_clustering(D,A,all_graphs)
            D,A = self._sequence_clustering(all_graphs)
            self._sequence_groups,self._sequence_ids = _do_fiedler_clustering(D,A,all_graphs)
            self.set_clustering(clustering_option)
        else:
            graph = all_graphs[0]
            graph.graph['id'] = graph.graph['pdb_id'] + "(" + str(1) + ")-" + str(1)
            graph.graph['group_val'] = 0.0
            self.protein_subgraphs[graph.graph['id']] = graph
            self.groups[1] = all_graphs
            self.clustering_option=clustering_option
            self._structural_groups,self._structural_ids = (self.groups,self.protein_subgraphs)
            self._sequence_groups,self._sequence_ids = (self.groups,self.protein_subgraphs)

    def set_clustering(self,clustering_option):
        ''' Sets clustering option.

        Parameters
        ----------
        clustering_option: str
            Either 'structural' or 'sequence'.

        Notes
        ------
        Since both types of clustering are always computed by :func:`pyemap.graph_mining.frequent_subgraph.SubgraphPattern.find_protein_subgraphs`
        all this function actually does is swap some private variables. The purpose of this function is to determine what kind of clustering 
        gets shown in the output.

        '''
        if clustering_option=="structural":
            self.groups,self.protein_subgraphs = (self._structural_groups,self._structural_ids)
        elif clustering_option=="sequence":
            self.groups,self.protein_subgraphs = (self._sequence_groups,self._sequence_ids)
        else:
            raise Exception("Either structural or sequence.")
        self.clustering_option = clustering_option
        for id,graph in self.protein_subgraphs.items():
            graph.graph['id']=id

    def _sequence_clustering(self,all_graphs):
        ''' Returns distance and adjacency matrices based on sequence clustering

        '''
        num_graphs = len(all_graphs)
        dims = (num_graphs+1, num_graphs+1)
        D = np.zeros(dims)
        A = np.ones(dims)*0.0001
        for i in range(0,num_graphs):
            A[i][i] = 0.0
        for i in range(0, len(all_graphs)):
            for j in range(i + 1, len(all_graphs)):
                seq1 = _get_sequence(all_graphs[i])
                seq2 = _get_sequence(all_graphs[j])
                dist = np.sum(np.absolute(np.array(seq1) - np.array(seq2)))
                if dist < len(seq1)+1:
                    A[i][j] = 1 / (dist + 1)
                    A[j][i] = 1 / (dist + 1)
            D[i][i] = np.sum(A[i])
        D[-1][-1] = np.sum(A[-1])
        return D, A

    def _structural_clustering(self, all_graphs):
        ''' Returns distance and adjacency matrices based on structural clustering

        '''
        num_graphs = len(all_graphs)
        dims = (num_graphs+1, num_graphs+1)
        D = np.zeros(dims)
        A = np.ones(dims)*0.0001
        for i in range(0,num_graphs):
            A[i][i] = 0.0
        for i in range(0, num_graphs):
            for j in range(i + 1, num_graphs):
                distance = self._subgraph_rmsd(all_graphs[i], all_graphs[j])
                if distance < 1:
                    A[i][j] = 1 / (distance + 1)
                    A[j][i] = 1 / (distance + 1)
            D[i][i] = np.sum(A[i])
        D[-1][-1] = np.sum(A[-1])
        return D, A

    def subgraph_rmsd(self,sg1,sg2):
        ''' Computes RMSD between two protein subgraphs of this class given their IDs.

        Parameters
        ----------
        sg1, sg2: str
            IDs for protein subgraphs

        Notes
        ------
        Only 'CA' are considered for standard residues. If two graphs cannot be superimposed, infinity is returned.
        
        Returns
        --------
        rmsd: float
            RMSD between protein subgraphs

        '''
        return self._subgraph_rmsd(self.protein_subgraphs[sg1],self.protein_subgraphs[sg2])

    def _subgraph_rmsd(self, sg1, sg2):
        ''' Computes RMSD between two protein subgraphs

        '''
        emap1 = self.support[sg1.graph['pdb_id']]
        emap2 = self.support[sg2.graph['pdb_id']]
        atoms1 = []
        atoms2 = []
        nodes1 = list(sg1.nodes)
        nodes2 = list(sg2.nodes)
        for i in range(0, len(nodes1)):
            res1 = emap1.residues[nodes1[i]]
            res2 = emap2.residues[nodes2[i]]
            if 'CA' in res1 and 'CA' in res2:
                atoms1.append(res1['CA'])
                atoms2.append(res2['CA'])
            else:
                shared_id = None
                for atm in res1:
                    if atm.id in res2:
                        shared_id = atm.id
                        break
                if shared_id is not None:
                    atoms1.append(res1[shared_id])
                    atoms2.append(res2[shared_id])
                else:
                    return float('inf')
        if len(atoms1) == len(nodes1):
            si = Superimposer()
            si.set_atoms(atoms1, atoms2)
            return si.rms
        else:
            return float('inf')

    def _find_subgraph_in_pdb(self,pdb_id):
        ''' Finds all monomorphisms of this subgrpah class in a given PDB.

        Parameters
        -----------
        pdb_id: str
            PDB ID of graph to be searched
        
        Returns
        --------
        sgs: list of :class:`networkx.Graph`        

        '''
        GM = get_graph_matcher(self.support[pdb_id].init_graph, self.G)
        subgraph_isos = GM.subgraph_monomorphisms_iter()
        sgs = []
        degree_dicts = []
        for mapping in subgraph_isos:
            sg = self._generate_protein_subgraph(mapping, self.support[pdb_id].init_graph, self.G, self.support[pdb_id])
            # eliminate redundant subgraphs
            degree_dict = dict(sg.degree)
            if degree_dict not in degree_dicts:
                degree_dicts.append(degree_dict)
                sgs.append(sg)
        sgs.sort(key=lambda x: x.size(weight="weight"))
        self.total_support[pdb_id] =  len(sgs) 
        return sgs



    def _generate_protein_subgraph(self, mapping, protein_graph, G, emap_obj):
        ''' Generates protein subgraph for a given monomorphism

        Parameters
        -----------
        mapping: dict of int:int
            Mapping of nodes in protein graph and generic subgraph
        protein_graph: :class:`networkx.Graph`
            Protein graph generated by pyemap
        G: :class:`networkx.Graph`
            Graph corresponding to subgraph pattern
        emap_obj: :class:`~pyemap.emap`
            eMap object corresponding to protein graph

        Returns
        --------
        protein_subgraph: :class:`networkx.Graph`
            Protein subgraph corresponding to mapping

        '''
        mapping = dict((v, k) for k, v in mapping.items())
        protein_subgraph = G.copy()
        protein_subgraph = nx.relabel_nodes(protein_subgraph, mapping)
        for node in protein_subgraph.nodes():
            protein_subgraph.nodes[node]['shape'] = protein_graph.nodes[node]['shape']
            protein_subgraph.nodes[node]['label'] = str(node)
            protein_subgraph.nodes[node]['aligned_resnum'] = emap_obj.residues[node].aligned_residue_number
            protein_subgraph.graph['pdb_id'] = protein_graph.graph['pdb_id']
        for edge in protein_subgraph.edges():
            for key in protein_graph.edges[edge]:
                protein_subgraph.edges[edge][key] = protein_graph.edges[edge][key]
        return protein_subgraph

    def subgraph_to_Image(self,id=None):
        '''Returns PIL image of subgraph pattern or protein subgraph

        Parameters
        -----------
        id: str, optional
            Protein subgraph ID. If not specified, generic subgraph pattern will be drawn

        Returns
        --------
        img: :class:`PIL.Image.Image`
        '''
        if id==None:
            G = self.G.copy()
        else:
            G= self.protein_subgraphs[id].copy()
        make_pretty_subgraph(G)
        agraph = to_agraph(G)
        agraph.graph_attr.update()
        agraph.edge_attr.update(len='1.0')
        fout = tempfile.NamedTemporaryFile(suffix=".png")
        agraph.draw(fout.name, prog='dot')
        img = Image.open(fout.name)
        return img

    def subgraph_to_file(self,id=None,dest=""):
        '''Saves image of subgraph pattern or protein subgraph to file

        Parameters
        -----------
        id: str, optional
            Protein subgraph ID. If not specified, generic subgraph pattern will be drawn
        dest; str,optional
            Destination to save the graph
        '''
        if id==None:
            temp_G = make_pretty_subgraph(self.G.copy())
            if dest=="":
                dest = self.id+".png"
        else:
            temp_G = self.protein_subgraphs[id]
            if dest=="":
                dest = self.id + "_" + id + ".png"
        agraph = to_agraph(temp_G)
        agraph.graph_attr.update()
        agraph.edge_attr.update(len='1.0')
        agraph.draw(dest, prog='dot')




        

